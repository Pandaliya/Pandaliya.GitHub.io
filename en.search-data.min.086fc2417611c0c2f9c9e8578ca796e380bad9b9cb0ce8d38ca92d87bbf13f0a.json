[{"id":0,"href":"/docs/history/2022/2208/","title":"8月","section":"2022年","content":"8月记 #  "},{"id":1,"href":"/docs/history/2022/2209/","title":"9月","section":"2022年","content":"9月记 #  "},{"id":2,"href":"/docs/category/css/01-flex%E5%B8%83%E5%B1%80/","title":"Flex弹性布局","section":"Css","content":"Flex弹性布局 #  Flex布局和传统布局比较\n传统布局的优缺点：\n 兼容性好 布局繁琐 不能很好的适用于移动端布局  Flex弹性布局：\n 操作方便，布局简单 PC端浏览器支持情况较差 IE 11或更低版本，部分支持  建议：PC端布局用传统布局；移动端或不考虑兼容性，用Flex布局\nFlex布局原理 #  Flex用来为盒子状模型提供最大的灵活性，任何一个容器都可以指定flex布局\n注意\n当我们为父盒子设为flex布局之后，子元素的float clear和vertical-align属性将失效  原理：采用Flex布局的元素，称为Flex容器（flex container）；它所有的子元素自动成为容器成员，称为Flex 项目（flex item）；项目可以横向排列也可以纵向排列。Flex布局就是通过给容器添加flex属性，来控制项目的位置和排列方式。\n父项常用属性 #  div {  /* 1 设置主轴的方向 */  flex-direction: row;   /* 2 设置主轴上子元素的排列方式 */  justify-content: flex-start;   /* 3 设置子元素是否换行*/  flex-wrap: nowrap;   /* 4 设置侧轴上子元素的排列方式（单行） */  align-items: flex-start;   /* 5 设置侧轴上子元素的排列方式（多行，子项出现换行）*/  align-content: flex-start;   /* 6 设置主轴和是否换行（列） */  flex-flow: row wrap; } flex-direction #  该属性设置主轴的方向。flex中的项目是沿着主轴排列的；我们可以通过设置flex-direction来设置主轴为X轴或Y轴\n属性值：\n row ：沿X轴从从左到右排列（默认排列方式） row-reverse: 沿X轴从从右到左排列 column: 设置主轴为Y轴，从上到下排列 column-reverse: ~，从下到上排列  justify-content #  该属性设置主轴上子元素的排列方式\n属性值：\n flex-start: 从左到右(默认值) flex-end: 从尾部开始布局 center: 居中布局 space-around: 平分剩余空间(将剩余空间平均分配给每个子项目); space-between：先两边贴边，平均再分配剩余的空间   PS: flex-end和上面的row-reverse不同，flex-end不会修改子元素的排列顺序\n flex-wrap #  该属性设置子元素在主轴方向上是否换行，flex布局中子元素是默认不换行的，如果装不开，会缩小子元素宽度（导致设置的宽度无效）。\n属性值：\n nowrap：不换行（默认值） wrap：换行  align-items #  设置侧轴子元素排列方式（单行）。\n属性值：\n flex-start：从上到下 flex-end：从下到上 center：居中 stretch: 拉伸  align-content #  设置侧轴子元素排列方式（多行）。\n属性值：\n flex-start：从侧轴起点开始排列 flex-end：从侧轴终点开始排列 center：在侧轴中间显示 space-around：子项在侧轴平分空间 space-between：子项在侧轴在分布在两端，再平分剩余空间 stretch：子项元素高度平分父元素高度  子项的常用属性 #  span {  /* 1 占剩余空间份数 */  flex: 1;   /* 2 子元素侧轴排列方式 */  align-self: flex-end;   /* 3 子元素顺序（默认是0，越小越靠前） */  order: -1; } flex #  该属性定义子项目分配剩余空间；flex定义占多少份。默认值是0, 1是占满剩余空间\nflex常用示例 #  1.两侧固定中间自适应\n\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;style\u0026gt;  section {  width: 60%;  height: 150px;  background-color: blue;  margin: 0 auto;  display: flex;  }  section div:nth-child(1) {  width:100px;  height:150px;  background-color: gray;  }   section div:nth-child(2) {  /* 关键代码 */  flex: 1;  background-color: white;  }   section div:nth-child(3) {  width:100px;  height:150px;  background-color: red;  }  \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section\u0026gt;  \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;  \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2.父视图平均分成3等份\n/* 三等分上例中的section */ section div {  flex: 1 }  section div:nth-child(2) {  /* 2号div占1半 */  flex: 2;  background-color: white; } align-self #  设置某一个子元素在侧轴的对齐方式\n属性值：\n flex-start：从上到下 flex-end：从下到上 center：居中 stretch: 拉伸  order #  定义子项的排列顺序，数值越小越靠前\n"},{"id":3,"href":"/posts/public_0201/","title":"Swift","section":"博客","content":"Swift #  Swift 是一种支持多编程范式和编译式的开源编程语言,苹果于2014年WWDC（苹果开发者大会）发布，用于开发 iOS，OS X 和 watchOS 应用程序。 Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。 Swift 在 Mac OS 和 iOS 平台可以和 Object-C 使用相同的运行环境。 2015年6月8日，苹果于WWDC 2015上宣布，Swift将开放源代码，包括编译器和标准库。\n"},{"id":4,"href":"/docs/category/css/02-first-page/","title":"02 First Page","section":"Css","content":"First page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":5,"href":"/docs/category/css/02-page-2/","title":"02 Page 2","section":"Css","content":"Second Page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":6,"href":"/docs/category/css/04-second-page/","title":"04 Second Page","section":"Css","content":"Second Page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":7,"href":"/docs/category/djiango/django_csrf/","title":"Django Csrf","section":"Djiango","content":"Django csrf防御机制 #  csrf（跨站请求伪造）攻击介绍 #  跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。\n这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求是发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。\n一个例子\n假如一家银行用以执行转账操作的URL地址如下： https://bank.example.com/withdraw?account=AccoutName\u0026amp;amount=1000\u0026amp;for=PayeeName\n那么，一个恶意攻击者可以在另一个网站上放置如下代码： \u0026lt;img src=\u0026quot;https://bank.example.com/withdraw?account=Alice\u0026amp;amount=1000\u0026amp;for=Badman\u0026quot; /\u0026gt;\n如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。\n透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户的浏览器，让其以用户的名义执行操作。\nDjango 防御 #  在客户端页面上添加csrftoken, 服务器端进行验证，服务器端验证的工作通过\u0026rsquo;django.middleware.csrf.CsrfViewMiddleware\u0026rsquo;这个中间层来完成。\n\u0026hellip;待续\nTips #  如何关闭验证\n在视图函数中添加csrf_exempt装饰\nfrom django.views.decorators.csrf import csrf_exempt  @csrf_exempt def post_data(request):  pass 在urlconf中配置\nfrom django.views.decorators.csrf import csrf_exempt urlpatterns = [  url(r\u0026#39;^post/get_data/$\u0026#39;, csrf_exempt(post_data), name=\u0026#39;post_data\u0026#39;),  ] "},{"id":8,"href":"/docs/category/djiango/django_post/","title":"Django Post","section":"Djiango","content":"Django RUSTApi 开发 #  Django实现Post请求 #  以下是在view中添加一个post请求的完整示例\n# views.py from django.http import HttpResponse, JsonResponse from django.views.decorators.csrf import csrf_exempt  # 如果需要取消该请求的CSRF验证,否则单独请求时会返回403 @csrf_exempt def markdown_wiki_update(request):  # 1. 非post请求直接返回  if request.method != \u0026#39;POST\u0026#39;:  return JsonResponse(RES_JSON_DICT)   # 2. 解析json形式的body  try:  json_body = json.loads(request.body)  except Exception as e:  print(\u0026#39;Reason:\u0026#39;, e)  return JsonResponse(RES_JSON_DICT)   # 3. 数据更新操作  # ...   # 4. 构建返回对象  resp = RES_JSON_DICT  resp[RESP_STATUS] = \u0026#39;success\u0026#39;  resp[RESP_MSG] = \u0026#39;update success\u0026#39;   # 5. 返回json信息  return JsonResponse(resp) 使用requests发起post请求 #  import requests, json  req_url = \u0026#39;...\u0026#39; json_body = json.dumps({\u0026#34;data\u0026#34;: infos}) resp = requests.post(req_url, data=json_body) json_resp = resp.json() if json_resp[\u0026#34;status\u0026#34;] == \u0026#39;success\u0026#39;:  return True "},{"id":9,"href":"/docs/category/djiango/model_backup/","title":"Model Backup","section":"Djiango","content":"数据（Model）备份 #  dumpdata #  django的dumpdata可以备份（导出）模型实例或整个数据库\n# 导出整个数据库 python manage.py dumpdata \u0026gt; db.json  # 导出某个app（备份admin到admin.json） python manage.py dumpdata admin \u0026gt; admin.json  # 导出某个app（指定settings） python manage.py dumpdata appname --settings=settings.settings_dev_win \u0026gt; ./resource/appname.json loaddata #  我们可以使用loaddata将备份数据导入到数据库中\n# 导入某个数据库 python manage.py loaddata --settings=settings.settings_dev_win ./esource/appname.json 遇到的问题 #  编码问题 #  在使用loaddata出现以下错误：\n Python: Can dumpdata cannot loaddata back. UnicodeDecodeError\n 解决方法：将导出的json文件使用utf-8编码重写保存（推荐使用vscode）\n注意settings设置 #  导出和导入时使用同一个settings文件（至少要包含所导入的app）\n"},{"id":10,"href":"/docs/category/djiango/model_filter/","title":"Model Filter","section":"Djiango","content":"模型操作之查询与修改 #  创建数据模型完成，Django自动提供一套数据库操作API，运行创建，查询，更新和删除对象。本文介绍这些常用操作。\n1.0 检索最新修改的10个对象 #  这个操作设计以下几个api\nobjects和QuerySet #  模型创建完成后，就会自动生成一个默认名称为objects的Manager，Manager提供一系列的api来生成满足特定条件的QuerySet。\n一个QuerySet代表满足特定条件的集合，在SQL层面上对应SELECT语句。\n# 只能通过模型类访问Managers, 而不能是具体的实例 MyModel.objects  # 返回模型的所有实例 MyModel.objects.all() 切片 #  可以使用python数组切片语法将QuerySet切成指定长度\n# 返回前5个实例（LIMIT 5） MyModel.objects.all()[:5]  # 返回第6到10个对象（OFFSET 5 LIMIT 5） MyModel.objects.all()[5:10]  # 不支持负索引，下面的代码会抛出异常而不是返回最后5个实例 # MyModel.objects.all()[-5:]  # 默认情况返回的QuerySet并为执行查询，但是使用切片的步长语法时将会执行查询 # 获取前10个对象，每隔一个对象取出组成列表 MyModel.objects.all()[:10:2] order_by #  order_by使用特定参数执行对象排序。\n# 以update_time排序（正序） MyModel.objects.order_by(\u0026#39;update_time\u0026#39;)  # 以update_time排序（逆序） MyModel.objects.order_by(\u0026#39;-update_time\u0026#39;)  # 检索最新修改的10个对象 MyModel.objects.order_by(\u0026#39;-update_time\u0026#39;)[:10] 处理异常 #  当使用get查找对象不存在时，会出发DoesNotExist异常\ntry:  md = MyModel.objects.get(pk=1) except MyModel.DoesNotExist:  md = None filter #  如何用filter表示\u0026quot;不等于\u0026quot;概念\nfrom django.db.models import Q dps = DiaryPlan.objects.filter(~Q(plan_status=\u0026#39;5\u0026#39;)) 过滤日期 #  "},{"id":11,"href":"/docs/category/djiango/template/","title":"Template","section":"Djiango","content":"常用模板语法 #  include #  include就是引入其他文件内容，把网页中的公共部分拿出来，重复利用，方便改动。\n\u0026lt;!-- 引入广告页面 --\u0026gt; {% include \u0026#39;ad.html\u0026#39; %} 传递变量 #  # views.py  def homepage(request):  title = \u0026#34;my site\u0026#34;  return render(request, \u0026#39;home.html\u0026#39;, {\u0026#39;title\u0026#39;:title})   # 模板中使用homepage.html # \u0026lt;p\u0026gt;{{ title }}\u0026lt;/p\u0026gt; 变量作为标签属性 #  可以直接使用，如下的变量month_str\n\u0026lt;input class=\u0026#34;diary-month-picker\u0026#34; type=\u0026#34;text\u0026#34; id=\u0026#34;inputDate\u0026#34; placeholder=\u0026#34;选择月份\u0026#34; value=\u0026#34;{{ month_str }}\u0026#34;\u0026gt; 数组遍历 #  # views.py "},{"id":12,"href":"/docs/category/djiango/urls/","title":"Urls","section":"Djiango","content":"URL调度器 #  在Django中urls.py文件定义了url地址到视图的映射关系。本文介绍常见的url定义方式和注意问题\n###一个简单的例子\n# urls.py from django.urls import path, re_path  urlpatterns = [  # 匹配绝对地址  path(\u0026#39;articles/2003/\u0026#39;, views.special_case_2003),   # 传递参数  path(\u0026#39;detail/\u0026lt;int:year\u0026gt;/\u0026#39;, views.blog_detail),   # 使用正则  re_path(r\u0026#39;markdown/detail/*\u0026#39;, md_view.md_detail, name=\u0026#39;md_wiki_detail\u0026#39;), ]  # view.py def blog_detail(request, wid):  return HttpResponse(\u0026#34;hello world {}\u0026#34;.format(wid)) "},{"id":13,"href":"/docs/category/djiango/views/","title":"Views","section":"Djiango","content":"Views基础操作 #  将view拆分为多个文件 #  新建views包，将原有views.py文件移动到views包中（注意改名），下面是使用示例\n# 目录结构 \u0026#34;\u0026#34;\u0026#34; - views - - __init__.py - - base_views.py - urls.py ... \u0026#34;\u0026#34;\u0026#34; # __init__.py from .base_views import *  # urls.py from .views import base_view urlpatterns = [  path(\u0026#39;\u0026#39;, base_view.wiki_home, name=\u0026#39;wiki_home\u0026#39;), ] "},{"id":14,"href":"/docs/category/interview/0218_swift_interv_1/","title":"0218 Swift Interv 1","section":"Interview","content":"Swift面试刷题（一） #  swift基础面试题\n01 swift枚举的关联值和原始值怎么区分？ #  关联值：是指将枚举成员和其他类型的变量存储在一起 原始值：枚举成员可以使用相同类型的默认值预先绑定，这个默认值叫做原始值\nenum Date {  // 设置枚举成员关联值  case digit(year:Int, month:Int, day:Int)  case string(String) }  enum Grade: String {  case perfect = \u0026#34;A\u0026#34;  case great = \u0026#34;B\u0026#34;  // ... } 02 什么是延时存储属性？ #  使用lazy可以定义一个延时存储属性，在第一次使用时才进行初始化；\n使用lazy的注意点：\n lazy必须是var属性 lazy线程不安全，多线程同时访问时，无法保证只初始化一次  // 定义lazy属性 class PicView {  lazy var image: Image = {  return Image(data:data)  } } 03 什么是运算符重载？ #  类、结构体、枚举可以为现有的运算符提供自定义实现\n// 代码示例 struct Point {  var x: Int  var y: Int   static func + (p: Point1, p2: Point) {  return Point(x: p1.x+p2.x, y: p1.y+p2.y)  } } 04 定义静态方法时static和class的区别？ #  static定义的方法不可以被子类覆写（override）；class则可以\n05 swift中如何定义下标？ #  在swift中可以使用subscript给任意类型（枚举，结构体，类）定义下标\n06 说明swift中的初始化器 #  类/结构体/枚举都可以定义初始化器，结构体有默认的初始化器。类有两种初始化器，分别为：指定初始化器和便捷初始化器（convenience init），规则如下。\n 每个类至少有一个指定初始化器。 指定初始化器必须调用父类的指定初始化器；便捷初始化必须调用当前类的另一个初始化器，且最终必须调用一个指定初始化器。  07 Swift和OC的初始化方法有什么不同？ #   swift的初始化方法更加严格，初始化方法必须保证所有非optional的成员都完成初始化； swift提供convenience（便捷）初始化器  08 swift有那些闭包？ #  尾随闭包\n尾随闭包是一个书写在函数括号后面的闭包表达式，如果需要将一个很长的闭包表达式作为函数的最后一个参数传递给函数，则可以将这个闭包替换为尾随闭包；\n逃逸闭包和非逃逸闭包\n当一个闭包作为参数传递到一个函数中，但这个闭包在函数返回还会被执行，就叫作闭包从函数中逃逸。可以添加@escaping关键字指明这是一个逃逸闭包。\n// 定义一个数组用于存储闭包类型 var completionHandlers: [() -\u0026gt; Void] = []  // 在方法中将闭包当做实际参数,存储到外部变量中 func someFunctionWithEscapingClosure(completionHandler: @escaping () -\u0026gt; Void) {  completionHandlers.append(completionHandler) } 自动闭包\n自动闭包不接受任何参数，延迟求值，只有被调用时才返回被包装在其中的表达式的值。可以使用@autoclosure声明一个自动闭包参数。\nfunc getName() -\u0026gt; String{  print(#function)  return \u0026#34;DKJone\u0026#34; }  //@autoclosure func goodMooning(morning:Bool ,who:@autoclosure() -\u0026gt; String){  if morning {  print(\u0026#34;Good morning, (who())\u0026#34;)  } } 自动闭包有以下特性：\n @autoclosure 会自动将20封装成闭包 { 20 } @autoclosure 只支持 () -\u0026gt; T格式的参数 @autoclosure 并非只支持最后一个参数 有无@autoclosure 会后构成函数重载   函数重载：函数名相同，函数的参数个数或类型不同\n 09 swift中如何使用单例 #  使用静态let属性和private init来写单例\npublic class FileManager {  public static let shared = {   return FileManager  } } 10 swift语法糖的本质（实现原理） #  语法糖： 是指计算机语言中添加某项特殊的语法，这种语法对语言本身功能没影响。但更方便编程者使用。增强代码可读性，简化代码。\nswift语法糖包括：\n Selector if let guard ?(单问号) / ??(双问号：) /!(感叹号：强制解包)  11 如何解决循环引用 #   转换为值类型 delegate或闭包使用weak或unowned属性  12 如何理解copy-on-write? #  值类型（如struct）在复制时，复制对象和原对象在实际内存中指向同一个对象（内存地址）。只有修改复制对象时，才会在内存中创建一个新对象。\n为提升性能。Struct，String，Array，Dictionary，Set都使用了cooy-on-write技术\n13 swift为什么将String/Array/Dictionary设计为值类型 #   高效使用内存，值类型在栈上操作只是指针移动；引用类型在堆上 线程安全，值类型赋值是深拷贝操作，会从新创建一个新的对象，不同线程上的操作不相互影响  14 什么属性观察？ #  属性观察：是指在当前类对特定的属性进行检测。\nvar title: String {  willSet {  print(\u0026#34;willSet\u0026#34;, newValue)   }  didSet {  print(\u0026#34;didSet\u0026#34;, oldValue, title)  } } 有如下特性：\n willSet会传递新值，默认叫做newValue didSet传递旧值 初始化器中设置属性值不会触发willSet和didSet  15 swift自省和OC有什么区别？ #  自省就是判断某一个对象是否属于某一个类型的操作；\n[obj isKindOfClass:[Object class]]; [obj isMemberOfClass:[Object class]]; swift 使用is关键字\nif (obj is ClassA) {  // } 16 Swift中的扩展和OC的分类有什么不同？ #   扩展不能添加存储属性（会报编译错误）；分类可以通过运行时关联对象的形式添加属性 Swift的扩展可以作用于协议，结构体或枚举；分类只能作用于类  "},{"id":15,"href":"/docs/category/interview/0219_swift_interv_2/","title":"0219 Swift Interv 2","section":"Interview","content":"Swift面试刷题（二） #  Swift比较高级一点的面试题\n01 一个Sequence的索引是不是一定从0开始？ #  不一定；开始索引和Next方法实现相关。\nclass Countdown: Sequence, IteratorProtocol {  var count: Int  init(count: Int) {  self.count = count  }  func next() -\u0026gt; Int? {  if count == 0 {  return nil  } else {  defer { count -= 1 }  return count  }  } } 02 数组都实现了哪些协议？ #  CollectionType/MutableCollectionType\n// 生成器 protocol GeneratorType {  typealias Element;  mutating func next() -\u0026gt; Element? }  // 序列 // 生成器能不断生成下一个元素，但是已经生成的元素无法再次取到了。Sequence包含了元素和生成器对象的创建方法。 protocol SequenceType {  typealias Generator: GeneratorType  func generate)() -\u0026gt; Genrator }  // 集合（Collection） Collection在Sequence基础上实现了Indexable协议，可以基于位置访问元素 Collection的继承顺序 Collection(集合) -\u0026gt; Squence(序列) -\u0026gt; Generator(生成器)\n字面量初始化协议ExpressibleByArrayLiteral\n03 如何自定义模式匹配（Switch Case匹配）？ #  可以重载匹配模式运算符（~=）实现；这个运算符作用域是全局的。\nfunc ~= (pattern: String, value: Int) -\u0026gt; Bool {  if pattern == \u0026#34;eighty\u0026#34; {  return value == 80  } else if pattern == \u0026#34;not eighty\u0026#34; {  return value != 80  } else {  return false  } }  switch 80 { case \u0026#34;eighty\u0026#34;:  //编译通过并且匹配 case \u0026#34;not eighty\u0026#34;:  // default:  break } 04 编译选项 whole module optmization 优化了什么? #  编译器可以跨文件优化编译代码, 不局限于一个文件\n06 mutating get的作用是什么？ #  struct Person {  var name: String {  mutating get {  return store  }  } } 让不可变的对象不能取到name\n"},{"id":16,"href":"/docs/category/interview/1_base_1/","title":"1 Base 1","section":"Interview","content":"1.1 Swift和OC的主要区别 #  1.1.1 编程范式 #   swift支持函数式编程，面向协议编程，面向对象编程 OC主要以面向对象为主  说明：swift是比较现代的编程语言。swift支持协议和协议扩展，从而支持面向协议编程；在swift中函数可以作为参，返回值和变量值，从而支持函数式编程。\n1.1.2 类型安全 #   swift是一门类型安全的语言，在编译时会做类型检查，如果类型不匹配会抛出一个错误，编译失败。 OC检查到类型不匹配时仅抛出警告。类型最终在运行时确定  1.1.3 值类型增强 #   在siwft中struct（结构体），enum（枚举）和tulpe（元组）都是值类型。其中String/Array/Dictionary/Set都是用结构体实现的也是值类型。 OC中NSString, NSNumber和集合类都是引用类型  值类型的优势：\n 不变性：值类型在赋值时会从新创建一个新的值进行赋值。变量A对的修改，不会对变量B造成影响 独占性：引用类可能存在隐式的依赖，比如两个对象都持有同一个可变数组，那他们之间是有依赖的 可交换性  1.1.4 枚举增强 #   swift的枚举可以使用整形，浮点型，字符串；可以拥有属性和方法；可以支持泛型、协议和扩展。 OC的枚举只是一组整形值。  Swift枚举\n1.1.5 泛型 #   swift支持泛型，泛型类和泛型函数 OC仅仅在集合类型上添加了对泛型的支持  Swift泛型\n1.1.6 协议和扩展 #   Swift协议功能丰富，而且是强约束（遵守协议就要实现所有协议方法），可以用于结构体和枚举。配合协议扩展可以实现面向协议编程。 OC的协议是弱约束，提供optional特性。  1.1.7 函数闭包 #   在swift中可以直接定义函数类型变量，将函数作为参数和返回值。 在OC中不能定义函数类型变量，需要封装成selector或block。  "},{"id":17,"href":"/docs/category/interview/2_data_2_access_control/","title":"2 Data 2 Access Control","section":"Interview","content":"2.1 Swift访问控制 #  访问控制，限定了其他源文件和模块中的代码访问对当前模块或源文件中类/方法/属性的访问权限。Swift的访问控制基于两个概念，模块和源文件：\n 模块：一个框架（framework）或者一个app都被视为一个模块，可以使用import关键字导入 源文件：源文件就是模块中的单个源代码文件  访问控制级别 #  私有访问 #  私有访问指所修饰的方法只能在源文件中访问，该级别有两个关键字\nprivate 所修饰的方法或属性只能在当前类里面访问\nfileprivate 所修饰的方法或属性可以在当前源文件里访问\n内部访问 #  内部访问是指实体（类/方法/属性）可以被模块中的任意源文件访问，同时不可以被模块之外的源文件访问。内部访问是实体的默认访问级别，关键是internal（可以不写）\n公共访问 #  公共访问是指：实体可以被导入他所在模块的源文件使用（同时也可以在模块内的任意源文件使用）该级别有两个关键字。\npublic 实体可以被其他模块访问，但不可以被继承和重写（override）。在所在模块内可以被重写和继承\nopen 可以被任意模块访问，继承和重写\n代码实例 #  "},{"id":18,"href":"/docs/category/interview/kadun/","title":"Kadun","section":"Interview","content":"卡顿产生原因和优化 #  屏幕是根据VSync信号刷新屏幕；在两个VSync信号之间CPU要完成下一帧的计算任务，GPU要完成下一帧的渲染任务；如果当VSync信号到达时当前帧没渲染完成，那么屏幕就不会刷新，需要等待下一次VSync才会刷新。这实际就降低了屏幕的刷新率，使用户视觉上产生卡顿。\n优化思路 #  总体思路就是降低CPU和GPU消耗。\n降低CPU消耗的细节 #   不要频繁调整视图frame或者约束，尽量提前计算好一次调整 使用轻量级的对象，比如不需要交互的视图使用CALayer代替UIView 使用Autolayout会消耗额外性能 使用UImageView时，图片的Size和ImageView的Size最好保持对应（避免CPU做放缩操作） 避免创建过多的线程 耗时操作放到子线程（充分利用多核CPU）：文本处理（尺寸计算）；图片处理（解码，绘制）  图片异步解码的方式 #   首先拿到图片转换成CGImage 创建一个图形上下文 然后将CGImage通过DrawImage方法绘制到上下文中（这一步会进行解码） 然后从上图形上下文中提取CGImage数据，然后转换成UIImage数据，这个UIiamge数据就是解码后的image  GPU优化细节 #   减少视图层级 避免短时间，大量图片显示 GPU能处理的最大尺寸是4096x4096，一旦超过这个尺寸就会占用cpu资源进行处理，尽量不要超过这个尺寸 减少透明视图 opaque设置为YES（混合部分就要进行和成计算） 避免离屏渲染  离屏渲染 #  GPU有两种渲染方式：\n On-Screen Rendering（当前屏幕渲染）：在当前用于显示的屏幕缓冲区进行渲染操作； Off-Screen Rendering（离屏渲染）：在当前屏幕缓冲区以外开辟一个新缓冲区进行渲染；  离屏渲染产生原因？\n渲染的画家算法；上层\n那些操作会触发离屏渲染\n 光栅化，layer.shouldRastersize=YES 遮罩 mask 圆角 maskToBounds=YES 和 cornerRadius大于0同时设置 阴影（如果设置了layer.shadowPath就不会有离屏渲染）  "},{"id":19,"href":"/docs/category/interview/kvo_kvc/","title":"Kvo Kvc","section":"Interview","content":"KVO实践和原理 #  从下面两道面试题入手学习KVO\n iOS用什么方式实现一个对象的KVO？（KVO的本质是什么） 如何手动触发KVO？  KVC #  KVC面试题：\n 使用KVC设值是否会触发KVO？ KVC的赋值和取值过程是怎样的？原理是什么？  KVC的设值原理 #  KVC设置内部的调用原理（调用优先级）\n 找方法 setValue方法，_setValue方法 如果没找到则调用accessInstanceVariableDirectly（是否可以直接访问成员变量）。如果返回NO则查找终止，抛出异常。如果返回YES则进行第3步 按照：_key -\u0026gt; _isKey -\u0026gt; key -\u0026gt; isKey查找成员变量，找到后直接赋值 如果都没找到，则抛出异常   回答面试题1：会触发KVO，即使直接修改属性（不调用set方法）也会触发KVO；这个和我们自己直接修改成员变量不同（直接修改不会触发KVO）\n KVC的取值过程 #   按照getKey -\u0026gt; key -\u0026gt; isKey -\u0026gt; _key的顺序查找get方法 如果没找到则调用accessInstanceVariableDirectly（是否可以直接访问成员变量）。如果返回NO则查找终止，抛出异常。如果返回YES则进行第3步 按照：_key -\u0026gt; _isKey -\u0026gt; key -\u0026gt; isKey查找成员变量，找到后直接取值 如果都没找到，则抛出异常  "},{"id":20,"href":"/docs/category/interview/object_1/","title":"Object 1","section":"Interview","content":"1 OC对象的本质 #  我们平时编写的OC代码，底层实现是C/C++代码。OC中的对象是基于C/C++中的结构体实现的。\n1.1 将OC代码转成C/C++代码 #  使用clang的rewrite命令可以将OC转换成C++代码\n# 直接生成cpp代码（不推荐）   # 指定平台(iOS arm64) xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp  ps: 安装插件goto shell 可以很方便的在当前位置打开终端\n 1.2 NSObject的本质 #  分析C++代码，研究对象本质\nstruct NSObject_IMPL {  Class isa; // 64位（8个字节） };  // 其中Class是一个结构体指针 16个字节 #  使用class_getInstanceSize()函数获取对象占用的内存\n// 获取NSObject类的实例对象的大小 // 查看源码可知，它返回的是成员变量所占的空间大小 // 返回 8 class_getInstanceSize([NSObject class])  // 获取obj指针所指向内存的大小 // 需要先引入：#import \u0026lt;malloc/malloc.h\u0026gt; // 返回 16 malloc_size((__bridge const void *)obj) 回答面试题 #   一个NSObject对象占多少内存？\n  系统分配了16个字节给NSObject对象（通过malloc_size函数获得） 但NSObject对象内部只使用了8个字节的空间  查看对象的内存 #  通过Xcode工具：Debug-\u0026gt; Debug Workfllow -\u0026gt; View Memory（shift+command+m）可以实时查看内存数据。\n# 断点后可以使用如下命令操作内存 # 读内存 memory read 0x10dda990 x [内存地址]  # 写内存 memory write [内存地址] [数值] 内存布局 #  结构体第一个成员的地址值就是结构体的地址值（同理，数组第一个元素的地址值就是数组的地址值）；OC对象的 布局和结构体的布局相同的。\n PS: 大端：从低地址开始读（符合阅读习惯），小端：从高地址开始读（地址高低和数据位权一致）\n 继承关系的内存布局 #  // 面试题: 有如下继承关系，A和B的实例对象占多少内存 @interface A: NSObject {  int _a; } @end  @interface B: NSObject {  int _b; } @end  // 结构体内存对齐：结构体的大小必须是最大成员大小的倍数 /* struct A_IMPL { struct NSObject_IMPL NSObject_VARS; int _a; } struct A_IMPL { struct A_IMPL NSObject_VARS; int _b; } A,B都是占用16个字节 size(a) = 8 + 4 = 12 =\u0026gt; 16; A中会有4个字节为使用的地址，B对象会将_b成员放入A对象中的空白地址。 */ 属性和方法 #  我们创建出的实例对象只包含成员变量，不保存方法。方法其实是保存在类对象中。\n内存分配的注意点 #  iOS内存实际分配时也有对齐的概念。具体的实现在libmalloc库中的malloc_zone_calloc函数中；系统把内存也分为不同级别的几个桶，具体数值如下：\n// 小内存（16的倍数，最大256个字节） #define NANO_MAX_SIZE 256; /*Bucket Sized {16, 32, 48, 64, 80, 96, 112 ...} */sizeof #  sizeof是运算符；在编译的时候就可以确定值，编译时会转换成常数。\n1.3 OC对象的分类 #  OC中的对象分为三种：\n 实例对象 类对象 元类对象  实例对象 #  实例对象中存储的信息主要就是成员变量；每个实例对象中都有一个成员变量isa。并且isa肯定在结构体的最前面；所以对象的地址也就是isa指针的地址。\n 扩展：为什么每个实例对象都有isa？ 因为每个类都是继承NSObject，NSObject对象有isa成员\n 类对象 #  // 获取类对象 // 注意：class方法一直返回的就是类对象。 objc = [NSObject class] 类对象存储的信息：\n isa指针 superclass指针 类的属性信息（@property）；类的对象方法 类的协议信息（protocol）；类的成员变量描述信息信息（ivar）  元类对象 #  // 获取元类对象的方式 Class cls = objc_getClass([NSObject class])  // 判断是否为元类对象 class_isMetaClass(cls) 元类对象和类对象的内存结构是一样的，都是Class类型。类对象的存储信息：\n isa指针 superclass指针 类方法（+方法）  object_getClass和objc_getClass #  /* 如果obj是实例对象，返回class对象 如果obj是类对象，返回元类对象 如果obj是元类对象，返回基类（NSObject）的元类对象 */ Class object_getClass(id obj) {  if (obj) return obj-\u0026gt;getIsa();  else return Nil; }  // 根据类的名称字符串返回类对象 Class objc_getClass(const char *aClassName) {  if (!aClassName) return Nil;  return look_up_class(aClassName, NO, YES) } 1.4 isa和superclass #  面试题：\n 对象的isa指针指向哪里？ 对象的类信息存放在哪里？ 方法的调用过程？  实例方法的调用过程：通过实例对象的isa找到类对象，再从类对象中找到方法实现调用\nsuperclass #  类对象superclass指针指向父类的类对象； 元类对象的superclass指针指向父类的元类对象\nisa的细节 #  类对象的地址和实例对象的isa地址不同？\n# 16进制打印isa地址(person是一个实例对象) p/x (long)obj-\u0026gt;isa  # 如果直接打印会返回对象名称：NSObject p obj-\u0026gt;isa 解释：从64位开始，isa需要进行一次运算才能得到类对象地址：isa\u0026amp;ISA_MASK\nOC2.0 Class的数据结构 #  struct objc_object {  Class isa };  struct objc_class: objc_object {  Class superclass;  cache_t cache; // 方法缓存  class_data_bits_t bits; // 保存具体的类信息 }  // bits \u0026amp; FAST_DATA_MASK (面试时可以说时一个掩码) struct class_rw_t {  } "},{"id":21,"href":"/docs/category/interview/pod_01/","title":"Pod 01","section":"Interview","content":"关于Cocoapod的面试题 #  1.在使用Cocoapod创建私有库时遇到那些问题？ #   使用子目录，如果不使用子目录，我们在私有库中创建的目录不会同步到使用者中。 向私有库中添加资源文件，如图片/音频时，使用resource_bundle，可以减少资源文件冲突。但使用asset管理资源时如果我们把asset文件夹直接添加到resource_bundle中会无法访问到其中的文件。后来使用resource属性（描述文件spec中定义）是可以访问的。  "},{"id":22,"href":"/docs/category/python/py_list/","title":"Py List","section":"Python","content":"python数组（list） #  list是python内置的一种数据类型，他是一种顺序集合，可以添加和删除元素，其中元素类型不必相同。内部保存的是数据的指针。\nlist的增加元素的方式 #  append\nappend用来向list末尾追加单个元素（参数为集合时，也视为单个元素）。\ninsert\ninsert用来将单个元素插入到list中，参数包括插入点索引和插入元素\nextend\nextend用来链接list，将参数集合的元素降维添加到list中\n"},{"id":23,"href":"/docs/category/python/py_try_catch/","title":"Py Try Catch","section":"Python","content":"Python中的异常捕获 #  捕获所有异常 #  try:  # ... except Exception as e:  # ...  log(\u0026#39;Reason:\u0026#39;, e) "},{"id":24,"href":"/docs/history/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":25,"href":"/docs/history/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":26,"href":"/docs/history/hidden/","title":"Hidden","section":"编年史","content":"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "}]